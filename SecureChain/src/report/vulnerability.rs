//! Vulnerability data structures and related functionality
//! 
//! This module defines the core vulnerability types and categories
//! used throughout the BugForgeX analysis system.

use serde::{Deserialize, Serialize};
use std::fmt;

/// Represents a security vulnerability found in smart contract code
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Unique identifier for the vulnerability
    pub id: String,
    
    /// Human-readable title of the vulnerability
    pub title: String,
    
    /// Detailed description of the vulnerability
    pub description: String,
    
    /// Severity level (Critical, High, Medium, Low, Info)
    pub severity: String,
    
    /// Category of the vulnerability
    pub category: VulnerabilityCategory,
    
    /// Path to the file containing the vulnerability
    pub file_path: String,
    
    /// Line number where the vulnerability occurs (if available)
    pub line_number: Option<usize>,
    
    /// Code snippet showing the vulnerable code
    pub code_snippet: Option<String>,
    
    /// Recommendation for fixing the vulnerability
    pub recommendation: Option<String>,
    
    /// External references for more information
    pub references: Vec<String>,
    
    /// Common Weakness Enumeration (CWE) identifier
    pub cwe_id: Option<String>,
    
    /// Tool that detected this vulnerability
    pub tool: String,
    
    /// Confidence level of the detection (0.0 to 1.0)
    pub confidence: f64,
}

/// Categories of vulnerabilities that can be detected
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum VulnerabilityCategory {
    /// Reentrancy vulnerabilities
    Reentrancy,
    
    /// Access control issues
    AccessControl,
    
    /// Integer overflow and underflow
    IntegerOverflow,
    
    /// Unchecked external calls and exceptions
    UnhandledExceptions,
    
    /// Timestamp dependence vulnerabilities
    TimestampDependence,
    
    /// Low-level call issues
    LowLevelCalls,
    
    /// Denial of service vulnerabilities
    DenialOfService,
    
    /// Input validation problems
    InputValidation,
    
    /// Race condition vulnerabilities
    RaceCondition,
    
    /// Cryptographic issues
    Cryptography,
    
    /// Gas optimization issues
    GasOptimization,
    
    /// Code quality issues
    CodeQuality,
    
    /// Fuzzing-related findings
    Fuzzing,
    
    /// Symbolic execution findings
    SymbolicExecution,
    
    /// Other/miscellaneous vulnerabilities
    Other,
}

impl fmt::Display for VulnerabilityCategory {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VulnerabilityCategory::Reentrancy => write!(f, "Reentrancy"),
            VulnerabilityCategory::AccessControl => write!(f, "Access Control"),
            VulnerabilityCategory::IntegerOverflow => write!(f, "Integer Overflow"),
            VulnerabilityCategory::UnhandledExceptions => write!(f, "Unhandled Exceptions"),
            VulnerabilityCategory::TimestampDependence => write!(f, "Timestamp Dependence"),
            VulnerabilityCategory::LowLevelCalls => write!(f, "Low-Level Calls"),
            VulnerabilityCategory::DenialOfService => write!(f, "Denial of Service"),
            VulnerabilityCategory::InputValidation => write!(f, "Input Validation"),
            VulnerabilityCategory::RaceCondition => write!(f, "Race Condition"),
            VulnerabilityCategory::Cryptography => write!(f, "Cryptography"),
            VulnerabilityCategory::GasOptimization => write!(f, "Gas Optimization"),
            VulnerabilityCategory::CodeQuality => write!(f, "Code Quality"),
            VulnerabilityCategory::Fuzzing => write!(f, "Fuzzing"),
            VulnerabilityCategory::SymbolicExecution => write!(f, "Symbolic Execution"),
            VulnerabilityCategory::Other => write!(f, "Other"),
        }
    }
}

impl VulnerabilityCategory {
    /// Get the typical severity level for this category
    pub fn typical_severity(&self) -> &'static str {
        match self {
            VulnerabilityCategory::Reentrancy => "High",
            VulnerabilityCategory::AccessControl => "High",
            VulnerabilityCategory::IntegerOverflow => "Medium",
            VulnerabilityCategory::UnhandledExceptions => "Medium",
            VulnerabilityCategory::TimestampDependence => "Medium",
            VulnerabilityCategory::LowLevelCalls => "Medium",
            VulnerabilityCategory::DenialOfService => "High",
            VulnerabilityCategory::InputValidation => "Medium",
            VulnerabilityCategory::RaceCondition => "High",
            VulnerabilityCategory::Cryptography => "High",
            VulnerabilityCategory::GasOptimization => "Low",
            VulnerabilityCategory::CodeQuality => "Low",
            VulnerabilityCategory::Fuzzing => "Medium",
            VulnerabilityCategory::SymbolicExecution => "Medium",
            VulnerabilityCategory::Other => "Medium",
        }
    }

    /// Get description for this category
    pub fn description(&self) -> &'static str {
        match self {
            VulnerabilityCategory::Reentrancy => "Vulnerabilities where external calls can re-enter the contract during execution",
            VulnerabilityCategory::AccessControl => "Issues with permission and authorization mechanisms",
            VulnerabilityCategory::IntegerOverflow => "Mathematical operations that can overflow or underflow",
            VulnerabilityCategory::UnhandledExceptions => "External calls that don't handle failure cases properly",
            VulnerabilityCategory::TimestampDependence => "Logic that depends on block timestamp which can be manipulated",
            VulnerabilityCategory::LowLevelCalls => "Usage of low-level call functions that can be dangerous",
            VulnerabilityCategory::DenialOfService => "Vulnerabilities that can prevent normal contract operation",
            VulnerabilityCategory::InputValidation => "Missing or insufficient validation of input parameters",
            VulnerabilityCategory::RaceCondition => "Vulnerabilities due to concurrent execution or ordering dependencies",
            VulnerabilityCategory::Cryptography => "Issues with cryptographic implementations or randomness",
            VulnerabilityCategory::GasOptimization => "Inefficient gas usage patterns",
            VulnerabilityCategory::CodeQuality => "General code quality and maintainability issues",
            VulnerabilityCategory::Fuzzing => "Issues discovered through fuzzing and property testing",
            VulnerabilityCategory::SymbolicExecution => "Vulnerabilities found through symbolic execution analysis",
            VulnerabilityCategory::Other => "Other types of vulnerabilities not covered by specific categories",
        }
    }

    /// Get common mitigation strategies for this category
    pub fn mitigation_strategies(&self) -> Vec<&'static str> {
        match self {
            VulnerabilityCategory::Reentrancy => vec![
                "Use checks-effects-interactions pattern",
                "Implement reentrancy guards",
                "Use pull payment patterns",
            ],
            VulnerabilityCategory::AccessControl => vec![
                "Implement role-based access control",
                "Use modifiers for access restrictions",
                "Validate caller permissions",
            ],
            VulnerabilityCategory::IntegerOverflow => vec![
                "Use SafeMath library",
                "Upgrade to Solidity 0.8+",
                "Add bounds checking",
            ],
            VulnerabilityCategory::UnhandledExceptions => vec![
                "Check return values of external calls",
                "Use try-catch blocks",
                "Implement proper error handling",
            ],
            VulnerabilityCategory::TimestampDependence => vec![
                "Use block numbers instead of timestamps",
                "Implement tolerance for timestamp manipulation",
                "Use external time oracles",
            ],
            VulnerabilityCategory::LowLevelCalls => vec![
                "Avoid low-level calls when possible",
                "Properly handle call return values",
                "Use higher-level abstractions",
            ],
            VulnerabilityCategory::DenialOfService => vec![
                "Implement gas limits",
                "Use pull payment patterns",
                "Add circuit breakers",
            ],
            VulnerabilityCategory::InputValidation => vec![
                "Validate all input parameters",
                "Use require statements",
                "Implement proper bounds checking",
            ],
            VulnerabilityCategory::RaceCondition => vec![
                "Use commit-reveal schemes",
                "Implement proper ordering",
                "Add state locks",
            ],
            VulnerabilityCategory::Cryptography => vec![
                "Use established cryptographic libraries",
                "Implement proper randomness",
                "Regular security audits",
            ],
            VulnerabilityCategory::GasOptimization => vec![
                "Optimize storage access patterns",
                "Use efficient data structures",
                "Minimize external calls",
            ],
            VulnerabilityCategory::CodeQuality => vec![
                "Follow coding standards",
                "Add comprehensive documentation",
                "Implement proper testing",
            ],
            VulnerabilityCategory::Fuzzing => vec![
                "Fix property violations",
                "Add proper invariants",
                "Improve test coverage",
            ],
            VulnerabilityCategory::SymbolicExecution => vec![
                "Fix logical errors",
                "Add proper assertions",
                "Improve path coverage",
            ],
            VulnerabilityCategory::Other => vec![
                "Follow security best practices",
                "Regular code reviews",
                "Continuous monitoring",
            ],
        }
    }

    /// Get all vulnerability categories
    pub fn all_categories() -> Vec<VulnerabilityCategory> {
        vec![
            VulnerabilityCategory::Reentrancy,
            VulnerabilityCategory::AccessControl,
            VulnerabilityCategory::IntegerOverflow,
            VulnerabilityCategory::UnhandledExceptions,
            VulnerabilityCategory::TimestampDependence,
            VulnerabilityCategory::LowLevelCalls,
            VulnerabilityCategory::DenialOfService,
            VulnerabilityCategory::InputValidation,
            VulnerabilityCategory::RaceCondition,
            VulnerabilityCategory::Cryptography,
            VulnerabilityCategory::GasOptimization,
            VulnerabilityCategory::CodeQuality,
            VulnerabilityCategory::Fuzzing,
            VulnerabilityCategory::SymbolicExecution,
            VulnerabilityCategory::Other,
        ]
    }
}

impl Vulnerability {
    /// Create a new vulnerability
    pub fn new(
        title: String,
        description: String,
        severity: String,
        category: VulnerabilityCategory,
        file_path: String,
        tool: String,
    ) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            title,
            description,
            severity,
            category,
            file_path,
            line_number: None,
            code_snippet: None,
            recommendation: None,
            references: Vec::new(),
            cwe_id: None,
            tool,
            confidence: 0.5,
        }
    }

    /// Set line number for the vulnerability
    pub fn with_line_number(mut self, line_number: usize) -> Self {
        self.line_number = Some(line_number);
        self
    }

    /// Set code snippet for the vulnerability
    pub fn with_code_snippet(mut self, code_snippet: String) -> Self {
        self.code_snippet = Some(code_snippet);
        self
    }

    /// Set recommendation for the vulnerability
    pub fn with_recommendation(mut self, recommendation: String) -> Self {
        self.recommendation = Some(recommendation);
        self
    }

    /// Add reference to the vulnerability
    pub fn with_reference(mut self, reference: String) -> Self {
        self.references.push(reference);
        self
    }

    /// Set CWE ID for the vulnerability
    pub fn with_cwe_id(mut self, cwe_id: String) -> Self {
        self.cwe_id = Some(cwe_id);
        self
    }

    /// Set confidence level for the vulnerability
    pub fn with_confidence(mut self, confidence: f64) -> Self {
        self.confidence = confidence.clamp(0.0, 1.0);
        self
    }

    /// Check if this is a high-severity vulnerability
    pub fn is_high_severity(&self) -> bool {
        matches!(self.severity.as_str(), "Critical" | "High")
    }

    /// Check if this is a critical vulnerability
    pub fn is_critical(&self) -> bool {
        self.severity == "Critical"
    }

    /// Get severity priority (higher number = more severe)
    pub fn severity_priority(&self) -> u8 {
        match self.severity.as_str() {
            "Critical" => 5,
            "High" => 4,
            "Medium" => 3,
            "Low" => 2,
            "Info" => 1,
            _ => 0,
        }
    }

    /// Get a short summary of the vulnerability
    pub fn summary(&self) -> String {
        format!("[{}] {}: {}", self.severity, self.category, self.title)
    }

    /// Check if the vulnerability has sufficient information
    pub fn is_complete(&self) -> bool {
        !self.title.is_empty() 
            && !self.description.is_empty() 
            && !self.severity.is_empty() 
            && !self.file_path.is_empty()
    }
}

/// Severity levels for vulnerabilities
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Severity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

impl fmt::Display for Severity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Severity::Critical => write!(f, "Critical"),
            Severity::High => write!(f, "High"),
            Severity::Medium => write!(f, "Medium"),
            Severity::Low => write!(f, "Low"),
            Severity::Info => write!(f, "Info"),
        }
    }
}

impl Severity {
    /// Get all severity levels
    pub fn all_levels() -> Vec<Severity> {
        vec![
            Severity::Critical,
            Severity::High,
            Severity::Medium,
            Severity::Low,
            Severity::Info,
        ]
    }

    /// Get numeric priority for sorting
    pub fn priority(&self) -> u8 {
        match self {
            Severity::Critical => 5,
            Severity::High => 4,
            Severity::Medium => 3,
            Severity::Low => 2,
            Severity::Info => 1,
        }
    }
}

/// Utility functions for working with vulnerabilities
pub mod utils {
    use super::*;

    /// Sort vulnerabilities by severity and confidence
    pub fn sort_vulnerabilities(vulnerabilities: &mut [Vulnerability]) {
        vulnerabilities.sort_by(|a, b| {
            // First sort by severity (descending)
            let severity_cmp = b.severity_priority().cmp(&a.severity_priority());
            if severity_cmp != std::cmp::Ordering::Equal {
                return severity_cmp;
            }
            
            // Then by confidence (descending)
            let confidence_cmp = b.confidence.partial_cmp(&a.confidence).unwrap_or(std::cmp::Ordering::Equal);
            if confidence_cmp != std::cmp::Ordering::Equal {
                return confidence_cmp;
            }
            
            // Finally by title (ascending)
            a.title.cmp(&b.title)
        });
    }

    /// Filter vulnerabilities by severity
    pub fn filter_by_severity<'a>(vulnerabilities: &'a [Vulnerability], severity: &'a str) -> Vec<&'a Vulnerability> {
        vulnerabilities.iter().filter(|v| v.severity == severity).collect()
    }

    /// Filter vulnerabilities by category
    pub fn filter_by_category<'a>(vulnerabilities: &'a [Vulnerability], category: &'a VulnerabilityCategory) -> Vec<&'a Vulnerability> {
        vulnerabilities.iter().filter(|v| v.category == *category).collect()
    }

    /// Get vulnerability statistics
    pub fn get_vulnerability_stats(vulnerabilities: &[Vulnerability]) -> std::collections::HashMap<String, usize> {
        let mut stats = std::collections::HashMap::new();
        
        for vuln in vulnerabilities {
            *stats.entry(vuln.severity.clone()).or_insert(0) += 1;
        }
        
        stats
    }

    /// Calculate overall risk score based on vulnerabilities
    pub fn calculate_risk_score(vulnerabilities: &[Vulnerability]) -> f64 {
        let mut score = 0.0;
        
        for vuln in vulnerabilities {
            let severity_weight = match vuln.severity.as_str() {
                "Critical" => 10.0,
                "High" => 5.0,
                "Medium" => 2.0,
                "Low" => 1.0,
                "Info" => 0.1,
                _ => 0.0,
            };
            
            score += severity_weight * vuln.confidence;
        }
        
        score
    }
}
